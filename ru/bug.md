Основное преимущество использования методов вместо функций, помимо использования синтаксиса метода и отсутствия необходимости повторять тип `self` в каждой сигнатуре метода, касается организации. Мы поместили все, что мы можем делать с экземпляром типа в один блок `impl` вместо того, чтобы заставлять будущих пользователей нашего кода искать возможности `Rectangle` в различных местах предоставляемой библиотеки.

> ### Где оператор `->` ?
>
> В C и C ++ для вызова методов используются два разных оператора: вы используете `.` если вы вызываете метод для объекта напрямую и `->` если вы вызываете метод для указателя на объект и вам нужно сначала разыменовать указатель. Другими словами, если `object` является указателем, `object->something()` аналогичен `(*object).something()` .
>
> В Rust нет эквивалента оператору `->` ; вместо этого в Rust есть функция, называемая *автоматическим обращением и разыменованием* . Вызов методов - одно из немногих мест в Rust, которое имеет такое поведение.
>
> Вот как это работает: когда вы вызываете метод с помощью `object.something()` , Rust автоматически добавляет `&` , `&mut` или `*` чтобы `object` соответствовал сигнатуре метода. Другими словами, это то же самое:

<!-- CAN'T EXTRACT SEE BUG TODO -->
