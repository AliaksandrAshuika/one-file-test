# Vue.js Руководство по рендерингу на стороне сервера

::: tip ПРИМЕЧАНИЕ Для этого руководства требуются следующие минимальные версии Vue и поддерживающие библиотеки:

- vue & vue-server-renderer 2.3.0+
- vue-router 2.5.0+
- vue-loader 12.0.0+ и vue-style-loader 3.0.0+ Если вы ранее использовали Vue 2.2 с SSR, вы заметите, что рекомендуемая структура кода теперь [немного отличается](./guide/structure.md) (с новой опцией [runInNewContext,](./api/README.md#runinnewcontext) установленной в `false` ). Ваше существующее приложение должно продолжать работать, но рекомендуется перейти на новые рекомендации. :::

## Что такое рендеринг на стороне сервера (SSR)?

Vue.js - это фреймворк для создания клиентских приложений. По умолчанию компоненты Vue создают и обрабатывают DOM в браузере в качестве вывода. Тем не менее, также возможно преобразовать те же компоненты в строки HTML на сервере, отправить их непосредственно в браузер и, наконец, «гидрировать» статическую разметку в полностью интерактивное приложение на клиенте.

## Почему ССР?

По сравнению с традиционным SPA (одностраничное приложение) преимущество SSR заключается, прежде всего, в:

- Лучшее SEO, так как сканеры поисковых систем будут непосредственно видеть полностью отображаемую страницу. Обратите внимание, что на данный момент Google и Bing могут индексировать синхронные приложения JavaScript просто отлично. Синхронное время является ключевым словом там. Если ваше приложение запускается с загрузчиком, а затем загружает контент через Ajax, сканер не будет ждать, пока вы закончите. Это означает, что если у вас есть контент, извлекаемый асинхронно на страницах, где важен SEO, SSR может понадобиться.
- Более быстрое время для контента, особенно на медленном интернете или медленных устройствах. Разметка, отображаемая на сервере, не должна ждать, пока весь JavaScript будет загружен и выполнен для отображения, поэтому ваш пользователь увидит полностью визуализированную страницу раньше. Это обычно приводит к улучшению взаимодействия с пользователем и может быть критичным для приложений, где время на контент напрямую связано с коэффициентом конверсии. Есть также некоторые компромиссы, которые следует учитывать при использовании SSR:
- Ограничения развития. Специфичный для браузера код может использоваться только внутри определенных хуков жизненного цикла; некоторые внешние библиотеки могут нуждаться в особой обработке для запуска в приложении, отображаемом на сервере.
- Более сложные требования к настройке сборки и развертыванию. В отличие от полностью статического SPA, который может быть развернут на любом статическом файловом сервере, для приложения, отображаемого на сервере, требуется среда, в которой может работать сервер Node.js.
- Больше серверной нагрузки. Рендеринг полноценного приложения в Node.js, очевидно, будет более ресурсоемким, чем просто обработка статических файлов, поэтому, если вы ожидаете большой трафик, будьте готовы к соответствующей загрузке сервера и разумно применяйте стратегии кэширования. Прежде чем использовать SSR для своего приложения, первый вопрос, который вы должны задать, - действительно ли он вам нужен. Это в основном зависит от того, насколько важно время для контента для вашего приложения. Например, если вы создаете внутреннюю панель мониторинга, где дополнительные несколько сотен миллисекунд при начальной загрузке не имеют большого значения, SSR будет излишним. Однако в тех случаях, когда время для контента является абсолютно критическим, SSR может помочь вам достичь максимально возможной производительности начальной загрузки.

## SSR vs Prerendering

Если вы только расследование SSR для улучшения SEO кучки маркетинга страниц (например , `/` , `/about` , `/contact` , и т.д.), то вы , вероятно , хотите вместо **предварительной визуализации.** Вместо того, чтобы использовать веб-сервер для компиляции HTML на лету, предварительный рендеринг просто генерирует статические HTML-файлы для определенных маршрутов во время сборки. Преимущество заключается в том, что настройка предварительного рендеринга намного проще и позволяет сохранить ваш веб-интерфейс как полностью статичный сайт. Если вы используете веб-пакет, вы можете легко добавить предварительный рендеринг с помощью prerender [-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin) . Он был тщательно протестирован с приложениями Vue - и фактически, [создатель](https://github.com/chrisvfritz) является членом основной команды Vue.

## Об этом руководстве

​ This guide is focused on server-rendered Single-Page Applications using Node.js as the server. Mixing Vue SSR with other backend setups is a topic of its own and briefly discussed in a [dedicated section](./guide/non-node.md). ​ This guide will be very in-depth and assumes you are already familiar with Vue.js itself, and have decent working knowledge of Node.js and webpack. If you prefer a higher-level solution that provides a smooth out-of-the-box experience, you should probably give [Nuxt.js](https://nuxtjs.org/) a try. It's built upon the same Vue stack but abstracts away a lot of the boilerplate, and provides some extra features such as static site generation. However, it may not suit your use case if you need more direct control of your app's structure. Regardless, it would still be beneficial to read through this guide to better understand how things work together. ​ As you read along, it would be helpful to refer to the official [HackerNews Demo](https://github.com/vuejs/vue-hackernews-2.0/), which makes use of most of the techniques covered in this guide. ​ Finally, note that the solutions in this guide are not definitive - we've found them to be working well for us, but that doesn't mean they cannot be improved. They might get revised in the future - and feel free to contribute by submitting pull requests!
