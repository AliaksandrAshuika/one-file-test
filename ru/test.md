project_path: /web/fundamentals/_project.yaml book_path: /web/fundamentals/_book.yaml описание: Архитектура оболочки приложения поддерживает локальный пользовательский интерфейс и динамически загружает контент без ущерба для возможности связывания и обнаружения в Интернете.

{# wf_updated_on: 2019-05-02 #} {# wf_published_on: 2016-09-27 #} {# wf_blink_components: N / A #}

# Модель оболочки приложения {: .page-title}

{% include "web / _shared / Contributors / addyosmani.html"%}

Архитектура **оболочки приложения** (или оболочки приложения) - это один из способов создания прогрессивного веб-приложения, которое надежно и мгновенно загружается на экраны ваших пользователей, подобно тому, что вы видите в собственных приложениях.

«Оболочка» приложения представляет собой минимальный набор HTML, CSS и JavaScript, необходимых для работы пользовательского интерфейса, и при кэшировании в автономном режиме может обеспечить **мгновенную и надежную работу** пользователей при повторных посещениях. Это означает, что оболочка приложения не загружается из сети каждый раз, когда пользователь посещает ее. От сети нужен только необходимый контент.

Для [одностраничных приложений](https://en.wikipedia.org/wiki/Single-page_application) с архитектурой, насыщенной JavaScript, оболочка приложения является подходящим подходом. Этот подход основан на агрессивном кэшировании оболочки (с использованием [работника службы](/web/fundamentals/primers/service-worker/) ) для запуска приложения. Затем динамический контент загружается для каждой страницы с помощью JavaScript. Оболочка приложения полезна для быстрого вывода на экран начального HTML-кода без подключения к сети.

<img src="images/appshell.png" alt="Архитектура оболочки приложения">

Другими словами, оболочка приложения похожа на пакет кода, который вы публикуете в магазине приложений при создании собственного приложения. Это скелет вашего пользовательского интерфейса и основные компоненты, необходимые для запуска вашего приложения, но, скорее всего, не содержат данных.

Примечание. Попробуйте использовать кодовую лабораторию « [Первое прогрессивное веб-приложение»,](https://codelabs.developers.google.com/codelabs/your-first-pwapp/#0) чтобы узнать, как спроектировать и реализовать оболочку своего первого приложения для приложения погоды. Видео с [моделью Instant Loading with the App Shell](https://www.youtube.com/watch?v=QhUzmR8eZAo) также проходит через этот шаблон.

### Когда использовать модель оболочки приложения

Создание PWA не означает начинать с нуля. Если вы создаете современное одностраничное приложение, вы, вероятно, уже используете что-то похожее на оболочку приложения, называете вы это так или нет. Детали могут немного отличаться в зависимости от того, какие библиотеки или фреймворки вы используете, но сама концепция не зависит от фреймворка.

Архитектура оболочки приложения имеет наибольший смысл для приложений и сайтов с относительно неизменной навигацией, но изменяющимся содержимым. Ряд современных фреймворков и библиотек JavaScript уже поощряют отделение логики вашего приложения от его содержимого, что делает эту архитектуру более простой в применении. Для определенного класса веб-сайтов, которые имеют только статический контент, вы все равно можете следовать той же модели, но сайт на 100% является оболочкой приложения.

Чтобы увидеть, как Google построил архитектуру оболочки приложения, взгляните на [Построение прогрессивного веб-приложения Google I / O 2016](/web/showcase/2016/iowa2016) . Это реальное приложение началось с SPA для создания PWA, который предварительно кэширует контент с помощью сервис-воркера, динамически загружает новые страницы, плавно переключается между представлениями и повторно использует контент после первой загрузки.

### Преимущества {: # app-shell-sizes}

Преимущества архитектуры оболочки приложения с сервис-воркером:

- **Надежная и неизменно быстрая работа** . Повторные посещения очень быстрые. Статические ресурсы и пользовательский интерфейс (например, HTML, JavaScript, изображения и CSS) кэшируются при первом посещении, поэтому они мгновенно загружаются при повторных посещениях. Контент *может* кэшироваться при первом посещении, но обычно загружается, когда это необходимо.

- **Нативные взаимодействия** . Приняв модель оболочки приложения, вы можете создать опыт с мгновенной навигацией и взаимодействиями, аналогичными встроенным приложениям, с автономной поддержкой.

- **Экономное использование данных** . Разрабатывайте дизайн с минимальным использованием данных и разумно подходите к тому, что вы кешируете, потому что перечисление несущественных файлов (например, больших изображений, которые не отображаются на каждой странице) приводит к тому, что браузеры загружают больше данных, чем это строго необходимо. Несмотря на то, что данные относительно дешевы в западных странах, это не относится к развивающимся рынкам, где подключение является дорогим, а данные - дорогими.

## Требования {: # app-shell-requirements}

В идеале оболочка приложения должна:

- Загружать быстро
- Используйте как можно меньше данных
- Использовать статические ресурсы из локального кеша
- Отделить контент от навигации
- Получение и отображение контента для конкретной страницы (HTML, JSON и т. Д.)
- При желании кешировать динамический контент

Оболочка приложения сохраняет ваш пользовательский интерфейс локальным и динамически извлекает контент через API, но не жертвует возможностью связывания и обнаружения в Интернете. В следующий раз, когда пользователь обратится к вашему приложению, последняя версия отобразится автоматически. Перед использованием не нужно скачивать новые версии.

Примечание. Расширение аудита [Lighthouse](https://github.com/googlechrome/lighthouse) можно использовать для проверки того, достигает ли ваш PWA, использующий оболочку приложения, высокую планку производительности. [To the Lighthouse](https://www.youtube.com/watch?v=LZjQ25NRV-E) - это доклад, посвященный оптимизации PWA с помощью этого инструмента.

## Создание оболочки приложения {: # building-your-app-shell}

Структурируйте свое приложение, чтобы четко различать оболочку страницы и динамическое содержимое. В общем, ваше приложение должно загружать самую простую возможную оболочку, но при начальной загрузке должно включать в себя достаточно значимого содержимого страницы. Определите правильный баланс между скоростью и актуальностью данных для каждого из ваших источников данных.

&lt;figure&gt;
  &lt;img src="images/wikipedia.jpg"
    alt="Offline Wikipedia app using an application shell with content caching"&gt;
  &lt;figcaption&gt;Jake Archibald’s &lt;a href="https://wiki-offline.jakearchibald.com/wiki/Rick_and_Morty"&gt;offline Wikipedia application&lt;/a&gt; is a good example of a PWA that uses an app shell model. It loads instantly on repeat visits, but dynamically fetches content using JS. This content is then cached offline for future visits.
&lt;/figcaption&gt;
&lt;/figure&gt;

### Пример HTML для оболочки приложения {: # example-html-for-appshell}

В этом примере базовая инфраструктура приложения и пользовательский интерфейс отделяются от данных. Важно, чтобы начальная загрузка была как можно более простой, чтобы отображался только макет страницы при открытии веб-приложения. Некоторые из них поступают из индексного файла вашего приложения (встроенная модель DOM, стили), а остальное загружается из внешних скриптов и таблиц стилей.

Весь пользовательский интерфейс и инфраструктура кэшируются локально с помощью сервис-воркера, поэтому при последующих загрузках извлекаются только новые или измененные данные, вместо того, чтобы загружать все.

Ваш файл `index.html` в вашем рабочем каталоге должен выглядеть примерно так, как показано ниже. Это подмножество фактического содержимого, а не полный индексный файл. Посмотрим, что в нем содержится.

- HTML и CSS для «скелета» вашего пользовательского интерфейса с заполнителями для навигации и содержимого.
- Внешний файл JavaScript (app.js) для обработки навигации и логики пользовательского интерфейса, а также код для отображения сообщений, полученных с сервера, и их локального хранения с использованием механизма хранения, такого как IndexedDB.
- Манифест веб-приложения и загрузчик работника службы для включения автономных возможностей.

<div class="clearfix"></div>

```
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;App Shell&lt;/title&gt;
  &lt;link rel="manifest" href="/manifest.json"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;link rel="stylesheet" type="text/css" href="styles/inline.css"&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;header class="header"&gt;
    &lt;h1 class="header__title"&gt;App Shell&lt;/h1&gt;
  &lt;/header&gt;

  &lt;nav class="nav"&gt;
  ...
  &lt;/nav&gt;

  &lt;main class="main"&gt;
  ...
  &lt;/main&gt;

  &lt;div class="dialog-container"&gt;
  ...
  &lt;/div&gt;

  &lt;div class="loader"&gt;
    &lt;!-- Show a spinner or placeholders for content --&gt;
  &lt;/div&gt;

  &lt;script src="app.js" async&gt;&lt;/script&gt;
  &lt;script&gt;
  if (&#39;serviceWorker&#39; in navigator) {
    navigator.serviceWorker.register(&#39;/sw.js&#39;).then(function(registration) {
      // Registration was successful
      console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope);
    }).catch(function(err) {
      // registration failed :(
      console.log(&#39;ServiceWorker registration failed: &#39;, err);
    });
  }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
```

<div class="clearfix"></div>

Примечание. См. « [Первое прогрессивное веб-приложение»,](/web/fundamentals/codelabs/your-first-pwapp/) чтобы узнать больше об использовании оболочки приложения и рендеринга содержимого на стороне сервера. Оболочка приложения может быть реализована с использованием любой библиотеки или фреймворка, как описано в наших <a href="https://www.youtube.com/watch?v=srdKq0DckXQ">прогрессивных веб-приложениях во всех обсуждаемых фреймворках</a> . Доступны образцы с использованием Polymer ( <a href="https://shop.polymer-project.org">Shop</a> ) и React ( <a href="https://github.com/insin/react-hn">ReactHN</a> , <a href="https://github.com/GoogleChrome/sw-precache/tree/master/app-shell-demo">iFixit</a> ).

### Кэширование оболочки приложения {: # app-shell-caching}

An app shell can be cached using a manually written service worker or a generated service worker using a static asset precaching tool like [sw-precache](https://github.com/googlechrome/sw-precache).

Примечание. Примеры приведены только для общей информации и иллюстративных целей. Фактические используемые ресурсы, вероятно, будут отличаться для вашего приложения.

#### Кеширование оболочки приложения вручную

Below is example service worker code that caches static resources from the app shell into the [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) using service worker's `install` event:

```
var cacheName = &#39;shell-content&#39;;
var filesToCache = [
  &#39;/css/styles.css&#39;,
  &#39;/js/scripts.js&#39;,
  &#39;/images/logo.svg&#39;,

  &#39;/offline.html&#39;,

  &#39;/&#39;,
];

self.addEventListener(&#39;install&#39;, function(e) {
  console.log(&#39;[ServiceWorker] Install&#39;);
  e.waitUntil(
    caches.open(cacheName).then(function(cache) {
      console.log(&#39;[ServiceWorker] Caching app shell&#39;);
      return cache.addAll(filesToCache);
    })
  );
});
```

#### Использование sw-preache для кеширования оболочки приложения

Сервисный воркер, созданный с помощью sw-preache, будет кэшировать и обслуживать ресурсы, которые вы настраиваете как часть процесса сборки. Вы можете настроить предварительное кеширование каждого файла HTML, JavaScript и CSS, составляющего оболочку вашего приложения. Все будет работать и в автономном режиме, и быстро загружаться при последующих посещениях без дополнительных усилий.

Вот базовый пример использования sw-precache как части процесса сборки [gulp](http://gulpjs.com) :

```
gulp.task(&#39;generate-service-worker&#39;, function(callback) {
  var path = require(&#39;path&#39;);
  var swPrecache = require(&#39;sw-precache&#39;);
  var rootDir = &#39;app&#39;;

  swPrecache.write(path.join(rootDir, &#39;service-worker.js&#39;), {
    staticFileGlobs: [rootDir + &#39;/**/*.{js,html,css,png,jpg,gif}&#39;],
    stripPrefix: rootDir
  }, callback);
});
```

Чтобы узнать больше о кэшировании статических ресурсов, см. [Добавление Service Worker с помощью sw-](https://codelabs.developers.google.com/codelabs/sw-precache/index.html?index=..%2F..%2Findex#0) preache codelab.

Примечание: sw-precache полезен для автономного кэширования статических ресурсов. Для ресурсов времени выполнения / динамических ресурсов мы рекомендуем использовать нашу бесплатную библиотеку [sw-toolbox](https://github.com/googlechrome/sw-toolbox) .

## Заключение {: #conclusion}

Оболочка приложения, использующая Service worker, является мощным шаблоном для автономного кэширования, но она также обеспечивает значительный выигрыш в производительности в виде мгновенной загрузки для повторных посещений вашего PWA. Вы можете кэшировать оболочку своего приложения, чтобы оно работало в автономном режиме, и заполнять его содержимое с помощью JavaScript.

При повторных посещениях это позволяет получать значимые пиксели на экране без подключения к сети, даже если ваш контент в конечном итоге поступает оттуда.

## Отзыв {: #feedback}

{% include "web / _shared / Help.html"%}
