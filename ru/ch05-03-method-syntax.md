## Синтаксис метода

*Методы* похожи на функции: они объявляются с ключевым словом `fn` и своим именем, у них могут быть параметры и возвращаемое значение, и они содержат некоторый код, который запускается, когда они вызываются из другого места. Однако методы отличаются от функций тем, что они определены в контексте структуры (или перечисления, или объекта признака, которые мы рассмотрим в главах 6 и 17, соответственно), и их первый параметр всегда `self` , который представляет экземпляр структуры, для которой вызывается метод.

### Определение методов

Давайте изменим функцию `area` которая имеет экземпляр `Rectangle` в качестве параметра, и вместо этого создадим метод `area` определенный в структуре `Rectangle` , как показано в листинге 5-13.

<span class="filename">Имя файла: src / main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-13/src/main.rs}}
```

<span class="caption">Листинг 5-13. Определение метода <code>area</code> в структуре <code>Rectangle</code></span>

Чтобы определить функцию в контексте `Rectangle` , мы запускаем блок `impl` (реализация). Затем мы перемещаем функцию `area` в `impl` фигурные скобки и меняем первый (и только в данном случае) параметр на `self` в подписи и везде в теле. В `main` , где мы вызвали функцию `area` и передали `rect1` в качестве аргумента, вместо этого мы можем использовать *синтаксис метода* для вызова метода `area` в нашем экземпляре `Rectangle` . Синтаксис метода идет после экземпляра: мы добавляем точку, за которой следует имя метода, круглые скобки и любые аргументы.

В сигнатуре для `area` мы используем `&self` вместо `rectangle: &Rectangle` потому что Rust знает, что тип `self` - это `Rectangle` из-за того, что этот метод находится внутри контекста `impl Rectangle` . Обратите внимание, что нам по-прежнему нужно использовать `&` перед `self` , как мы это делали в `&Rectangle` . Методы могут владеть `self` , безвозвратно заимствовать `self` как мы сделали здесь, или заимствовать `self` изменчиво, как и любой другой параметр.

Мы выбрали `&self` по той же причине, по которой использовали `&Rectangle` в версии функции: мы не хотим брать на себя ответственность, и мы просто хотим читать данные в структуре, а не писать в нее. Если бы мы хотели изменить экземпляр, для которого мы вызвали метод, как часть того, что делает метод, мы бы использовали `&mut self` в качестве первого параметра. Редко иметь метод, который берет на себя ответственность за экземпляр, используя в качестве первого параметра только `self` ; этот метод обычно используется, когда метод преобразует `self` во что-то еще, и вы хотите запретить вызывающему объекту использовать исходный экземпляр после преобразования.

Основное преимущество использования методов вместо функций, помимо использования синтаксиса методов и отсутствия необходимости повторять тип `self` в каждой сигнатуре метода, касается организации. Мы поместили все, что мы можем делать с экземпляром типа в один блок `impl` вместо того, чтобы заставлять будущих пользователей нашего кода искать возможности `Rectangle` в различных местах в предоставляемой нами библиотеке.

> ### Где оператор `->` ?
>
> В C и C ++ для вызова методов используются два разных оператора: вы используете `.` если вы вызываете метод для объекта напрямую и `->` если вы вызываете метод для указателя на объект и вам нужно сначала разыменовать указатель. Другими словами, если `object` является указателем, `object->something()` аналогичен `(*object).something()` .
>
> В Rust нет эквивалента оператору `->` ; вместо этого в Rust есть функция, называемая *автоматическим обращением и разыменованием* . Вызов методов - одно из немногих мест в Rust, которое имеет такое поведение.
>
> Вот как это работает: когда вы вызываете метод с помощью `object.something()` , Rust автоматически добавляет `&` , `&mut` или `*` чтобы `object` соответствовал сигнатуре метода. Другими словами, это то же самое:

<!-- CAN'T EXTRACT SEE BUG TODO -->

> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> Первый выглядит намного чище. Такое поведение автоматической ссылки работает, потому что у методов есть четкий получатель - тип `self` . Учитывая получателя и имя метода, Rust может окончательно определить, является ли метод считыванием ( `&self` ), изменением ( `&mut self` ) или потреблением ( `self` ). Тот факт, что Rust делает заимствование неявным образом для приемников методов, в значительной степени способствует эргономичности владения на практике.

### Методы с большим количеством параметров

Попрактикуемся в использовании методов, реализовав второй метод в структуре `Rectangle` . На этот раз мы хотим, чтобы экземпляр `Rectangle` взял другой экземпляр `Rectangle` и вернул `true` если второй `Rectangle` может полностью уместиться внутри `self` ; в противном случае он должен вернуть `false` . То есть мы хотим иметь возможность написать программу, показанную в листинге 5-14, после того, как мы определили метод `can_hold` .

<span class="filename">Имя файла: src / main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-14/src/main.rs}}
```

<span class="caption">Listing 5-14: Using the as-yet-unwritten <code>can_hold</code> method</span>

И ожидаемый результат будет выглядеть следующим образом, потому что оба измерения `rect2` меньше размеров `rect1` но `rect3` шире, чем `rect1` :

```text
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```

Мы знаем, что хотим определить метод, поэтому он будет внутри блока `impl Rectangle` . Имя метода будет `can_hold` , и он будет принимать неизменяемое заимствование другого `Rectangle` в качестве параметра. Мы можем сказать, какой будет тип параметра, посмотрев на код, который вызывает метод: `rect1.can_hold(&rect2)` передает `&rect2` , который является неизменным заимствованием для `rect2` , экземпляра `Rectangle` . Это имеет смысл, потому что нам нужно только читать `rect2` (а не писать, что означало бы, что нам понадобится изменяемое заимствование), и мы хотим, чтобы `main` сохранил право собственности на `rect2` чтобы мы могли использовать его снова после вызова метода `can_hold` . Возвращаемое значение `can_hold` будет логическим, и реализация проверит, больше ли ширина и высота `self` , чем ширина и высота другого `Rectangle` , соответственно. Давайте добавим новый `can_hold` метод к `impl` блока из листинга 5-13, как показано в листинге 5-15.

<span class="filename">Имя файла: src / main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-15/src/main.rs:here}}
```

<span class="caption">Листинг 5-15. Реализация метода <code>can_hold</code> в <code>Rectangle</code> который принимает другой экземпляр <code>Rectangle</code> в качестве параметра</span>

Когда мы запустим этот код с функцией `main` Листинга 5-14, мы получим желаемый результат. Методы могут принимать несколько параметров, которые мы добавляем в подпись после параметра `self` , и эти параметры работают так же, как параметры в функциях.

### Связанные функции

Еще одна полезная особенность блоков `impl` заключается в том, что нам разрешено определять функции внутри блоков `impl` которые *не* принимают `self` в качестве параметра. Они называются *связанными функциями,* потому что они связаны со структурой. Они по-прежнему являются функциями, а не методами, потому что у них нет экземпляра структуры для работы. Вы уже использовали связанную функцию `String::from` .

Связанные функции часто используются для конструкторов, которые возвращают новый экземпляр структуры. Например, мы могли бы предоставить связанную функцию, которая будет иметь один параметр измерения и использовать его как ширину и высоту, тем самым упростив создание квадратного `Rectangle` вместо того, чтобы указывать одно и то же значение дважды:

<span class="filename">Имя файла: src / main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-03-associated-functions/src/main.rs:here}}
```

Чтобы вызвать эту связанную функцию, мы используем синтаксис `::` с именем структуры; `let sq = Rectangle::square(3);` это пример. Пространство имен этой функции определяется структурой: синтаксис `::` используется как для связанных функций, так и для пространств имен, созданных модулями. Мы обсудим модули в главе 7.

### Множественные блоки `impl`

Каждая структура может иметь несколько блоков `impl` . Например, листинг 5-15 эквивалентен коду, показанному в листинге 5-16, в котором каждый метод находится в собственном блоке `impl` .

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-16/src/main.rs:here}}
```

<span class="caption">Листинг 5-16. Переписывание листинга 5-15 с использованием нескольких блоков <code>impl</code></span>

Здесь нет причин разделять эти методы на несколько блоков `impl` , но это допустимый синтаксис. Мы увидим случай, когда несколько блоков `impl` будут полезны в главе 10, где мы обсудим общие типы и свойства.

## Резюме

Структуры позволяют создавать настраиваемые типы, значимые для вашего домена. Используя структуры, вы можете сохранить связанные части данных связанными друг с другом и дать каждой части имя, чтобы сделать ваш код понятным. Методы позволяют вам указывать поведение экземпляров ваших структур, а связанные функции позволяют вам выполнять функции пространства имен, специфичные для вашей структуры, без наличия доступного экземпляра.

Но структуры - не единственный способ создания пользовательских типов: давайте обратимся к функции enum в Rust, чтобы добавить еще один инструмент в ваш набор инструментов.
