---
layout: Почта
title: Представляем Rust 1.51.0
author: Команда релиза Rust
release: правда
---

Команда Rust рада анонсировать новую версию Rust 1.51.0. Rust - это язык программирования, который дает каждому возможность создавать надежное и эффективное программное обеспечение.

Если у вас установлена предыдущая версия Rust через rustup, получить Rust 1.51.0 так же просто, как:

```console
rustup update stable
```

Если у вас его еще нет, вы можете [получить `rustup`] на соответствующей странице нашего веб-сайта и ознакомиться с [подробными примечаниями к выпуску 1.51.0] на GitHub.

## Что в стабильной версии 1.51.0

Этот выпуск представляет собой одно из крупнейших дополнений к языку Rust и Cargo за долгое время, стабилизируя MVP дженериков const и новый преобразователь функций для Cargo. Давайте прямо в это погрузимся!

### Const Generics MVP

До этого выпуска Rust позволял параметризовать типы по времени жизни или типам. Например, если бы мы хотели иметь `struct` которая является универсальной по типу элемента массива, мы бы написали следующее:

```rust
struct FixedArray<T> {
              // ^^^ Type generic definition
    list: [T; 32]
        // ^ Where we're using it.
}
```

Если затем мы используем `FixedArray<u8>` , компилятор создаст мономорфную версию `FixedArray` которая выглядит так:

```rust
struct FixedArray<u8> {
    list: [u8; 32]
}
```

Это мощная функция, позволяющая писать повторно используемый код без дополнительных затрат времени выполнения. Однако до этого выпуска было невозможно легко сделать общие для *значений* этих типов. Это было особенно заметно в массивах, длина которых указана в определении их типа ( `[T; N]` ), что раньше вы не могли использовать в качестве универсального. Теперь с 1.51.0 вы можете написать код, который является универсальным для значений любого типа integer, `bool` или `char` ! (Использование `struct` или `enum` по-прежнему нестабильно.)

Это изменение теперь позволяет нам иметь нашу собственную структуру массива, которая является универсальной по своему типу *и* длине. Давайте посмотрим на пример определения и то, как его можно использовать.

```rust
struct Array<T, const LENGTH: usize> {
    //          ^^^^^^^^^^^^^^^^^^^ Const generic definition.
    list: [T; LENGTH]
    //        ^^^^^^ We use it here.
}
```

Теперь, если мы затем использовали `Array<u8, 32>` , компилятор создаст мономорфную версию `Array` которая выглядит так:

```rust
struct Array<u8, 32> {
    list: [u8; 32]
}
```

Дженерики Const добавляют важный новый инструмент для разработчиков библиотек в создании новых мощных безопасных API-интерфейсов во время компиляции. Если вы хотите узнать больше о константных дженериках, вы также можете почитать [сообщение в блоге «Const Generics MVP Hits Beta»] для получения дополнительной информации об этой функции и ее текущих ограничениях. Нам не терпится увидеть, какие новые библиотеки и API вы создаете!

### `array::IntoIter` Stabilization

В рамках стабилизации константных дженериков мы также стабилизируем новый API, который его использует, `std::array::IntoIter` . `IntoIter` позволяет создавать итератор по значению для любого массива. Раньше не было удобного способа перебора собственных значений массива, только ссылки на них.

```rust
fn main() {
  let array = [1, 2, 3, 4, 5];

  // Previously
  for item in array.iter().copied() {
      println!("{}", item);
  }

  // Now
  for item in std::array::IntoIter::new(array) {
      println!("{}", item);
  }
}
```

Обратите внимание, что это добавляется как отдельный метод вместо `.into_iter()` в массивы, так как в настоящее время это приводит к некоторой поломке; в настоящее время `.into_iter()` относится к итератору среза по ссылке. Мы изучаем способы сделать это более эргономичным в будущем.

### Новая функция распознавания функций Cargo

Управление зависимостями - сложная проблема, и одна из самых сложных ее частей - это просто выбрать, какую *версию* зависимости использовать, когда она зависит от двух разных пакетов. Это не только включает номер версии, но и то, какие функции включены или не включены для пакета. По умолчанию Cargo объединяет функции одного пакета, когда он упоминается несколько раз в графе зависимостей.

Например, предположим, что у вас есть зависимость под названием `foo` с функциями A и B, которая использовалась пакетами `bar` и `baz` , но `bar` зависит от `foo+A` а `baz` зависит от `foo+B` Cargo объединит обе эти функции и скомпилирует `foo` как `foo+AB` . Это дает преимущество в том, что вам нужно только `foo` , а затем его можно повторно использовать как для `bar` и для `baz` .

Однако у этого есть и обратная сторона. Что делать, если функция, включенная в зависимости сборки, несовместима с целью, для которой вы строите?

Типичным примером этого в экосистеме является необязательная `std` включенная во многие `#![no_std]` ящики, которая позволяет ящикам предоставлять дополнительную функциональность, когда `std` доступен. Теперь представьте, что вы хотите использовать `#![no_std]` версию `foo` в `#![no_std]` и использовать `foo` во время сборки в `build.rs` . Если ваша зависимость от времени сборки зависит от `foo+std` , ваш двоичный файл теперь также зависит от `foo+std` , что означает, что он больше не будет компилироваться, потому что `std` недоступен для вашей целевой платформы.

Это было давно вопросом в грузовом отсеке, и с этим выпуском есть новый `resolver` вариант в вашем `Cargo.toml` , где вы можете установить `resolver="2"` , чтобы сказать груз , чтобы попробовать новый подход к решению возможностей. Вы можете ознакомиться с [RFC 2957] для получения подробного описания поведения, которое можно резюмировать следующим образом.

- **Зависимости разработчиков** - когда пакет используется совместно как обычная зависимость и зависимость от разработчиков, функции зависимости от разработчиков включаются только в том случае, если текущая сборка включает зависимости от разработчиков.
- **Зависимости хоста** - когда пакет совместно используется как обычная зависимость и зависимость сборки или proc-макрос, функции для нормальной зависимости сохраняются независимо от зависимости сборки или макроса proc.
- **Целевые зависимости** - когда пакет появляется несколько раз в графе сборки, и один из этих экземпляров является зависимостью, зависящей от цели, тогда функции зависимости, зависящей от цели, включаются только в том случае, если цель в настоящее время строится.

Хотя это может привести к компиляции некоторых ящиков более одного раза, это должно обеспечить гораздо более интуитивный опыт разработки при использовании функций с грузом. Если вы хотите узнать больше, вы также можете прочитать [раздел «Feature Resolver»] в Cargo Book для получения дополнительной информации. Мы хотели бы поблагодарить команду Cargo и всех участников за их тяжелую работу по разработке и внедрению нового резольвера!

```toml
[package]
resolver = "2"
# Or if you're using a workspace

[workspace]
resolver = "2"
```

### Разделение отладочной информации

Хотя это и нечасто освещается в выпуске, команды Rust постоянно работают над улучшением времени компиляции Rust, и этот выпуск знаменует собой одно из крупнейших улучшений за долгое время для Rust на macOS. Информация об отладке сопоставляет двоичный код с вашим исходным кодом, чтобы программа могла предоставить вам больше информации о том, что пошло не так во время выполнения. В macOS отладочная информация ранее собиралась в одну `.dSYM` с помощью инструмента под названием `dsymutil` , что может занять некоторое время и занять довольно много места на диске.

Сбор всей отладочной информации в этом каталоге помогает найти ее во время выполнения, особенно если двоичный файл перемещается. Однако у него есть недостаток, заключающийся в том, что даже когда вы вносите небольшие изменения в свою программу, `dsymutil` необходимо будет запустить весь окончательный двоичный файл, чтобы создать окончательную папку `.dSYM` Иногда это может значительно увеличить время сборки, особенно для больших проектов, поскольку все зависимости всегда вспоминаются, но это был необходимый шаг, поскольку без него стандартная библиотека Rust не знала, как загрузить отладочную информацию в macOS.

Недавно обратная трассировка Rust переключилась на использование другого бэкэнда, который поддерживает загрузку debuginfo без необходимости запускать `dsymutil` , и мы стабилизировали поддержку пропуска запуска `dsymutil` Это может значительно ускорить сборку, включающую отладочную информацию, и значительно уменьшить объем используемого дискового пространства. Мы не проводили обширных тестов, но видели множество отчетов о том, что сборки людей с таким поведением намного быстрее работают на macOS.

Вы можете включить это новое поведение, установив `-Csplit-debuginfo=unpacked` флаг при выполнении `rustc` , или путем установки [`split-debuginfo`] `[profile]` опцию `unpacked` в Cargo. Параметр «unpacked» указывает rustc оставить объектные файлы .o в каталоге вывода сборки, а не удалять их, и пропускает этап запуска dsymutil. Поддержка обратной трассировки в Rust достаточно умен, чтобы знать, как найти эти файлы .o. Такие инструменты, как lldb, тоже умеют это делать. Это должно работать до тех пор, пока вам не нужно перемещать двоичный файл в другое место, сохраняя при этом отладочную информацию.

```toml
[profile.dev]
split-debuginfo = "unpacked"
```

### Стабилизированные API

Всего в этом выпуске было стабилизировано 18 новых методов для различных типов, таких как `slice` и `Peekable` . Заметным дополнением является стабилизация `ptr::addr_of!` и `ptr::addr_of_mut!` , которые позволяют создавать необработанные указатели на невыровненные поля. Раньше это было невозможно, потому что Rust требует, чтобы `&/&mut` был выровнен и указывал на инициализированные данные, а `&addr as *const _` тогда вызывал бы неопределенное поведение, поскольку `&addr` нужно было выровнять. Эти два макроса теперь позволяют безопасно создавать невыровненные указатели.

```rust
use std::ptr;

# [repr(packed)]

struct Packed {
    f1: u8,
    f2: u16,
}

let packed = Packed { f1: 1, f2: 2 };
// `&packed.f2` would create an unaligned reference, and thus be Undefined Behavior!
let raw_f2 = ptr::addr_of!(packed.f2);
assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);
```

Были стабилизированы следующие методы.

- [`Arc::decrement_strong_count`]
- [`Arc::increment_strong_count`]
- [`Once::call_once_force`]
- [`Peekable::next_if_eq`]
- [`Peekable::next_if`]
- [`Seek::stream_position`]
- [`array::IntoIter`]
- [`panic::panic_any`]
- [`ptr::addr_of!`]
- [`ptr::addr_of_mut!`]
- [`slice::fill_with`]
- [`slice::split_inclusive_mut`]
- [`slice::split_inclusive`]
- [`slice::strip_prefix`]
- [`slice::strip_suffix`]
- [`str::split_inclusive`]
- [`sync::OnceState`]
- [`task::Wake`]

### Прочие изменения

В выпуске Rust 1.51.0 есть и другие изменения: узнайте, что изменилось в [Rust](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1510-2021-03-25) , [Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-151-2021-03-25) и [Clippy](https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-151) .

### Участники 1.51.0

Многие люди собрались вместе, чтобы создать Rust 1.51.0. Мы бы не справились без вас. [Спасибо!](https://thanks.rust-lang.org/rust/1.51.0/)


[получить `rustup`]: https://www.rust-lang.org/install.html
[подробными примечаниями к выпуску 1.51.0]: https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1510-2021-03-25
[сообщение в блоге «Const Generics MVP Hits Beta»]: https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html
[RFC 2957]: https://rust-lang.github.io/rfcs/2957-cargo-features2.html
[раздел «Feature Resolver»]: https://doc.rust-lang.org/nightly/cargo/reference/features.html#feature-resolver-version-2
[`split-debuginfo`]: https://doc.rust-lang.org/nightly/cargo/reference/profiles.html#split-debuginfo
[`Once::call_once_force`]: https://doc.rust-lang.org/stable/std/sync/struct.Once.html#method.call_once_force
[`sync::OnceState`]: https://doc.rust-lang.org/stable/std/sync/struct.OnceState.html
[`panic::panic_any`]: https://doc.rust-lang.org/stable/std/panic/fn.panic_any.html
[`slice::strip_prefix`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.strip_prefix
[`slice::strip_suffix`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.strip_suffix
[`Arc::increment_strong_count`]: https://doc.rust-lang.org/stable/std/sync/struct.Arc.html#method.increment_strong_count
[`Arc::decrement_strong_count`]: https://doc.rust-lang.org/stable/std/sync/struct.Arc.html#method.decrement_strong_count
[`slice::fill_with`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.fill_with
[`ptr::addr_of!`]: https://doc.rust-lang.org/stable/std/ptr/macro.addr_of.html
[`ptr::addr_of_mut!`]: https://doc.rust-lang.org/stable/std/ptr/macro.addr_of_mut.html
[`array::IntoIter`]: https://doc.rust-lang.org/stable/std/array/struct.IntoIter.html
[`slice::split_inclusive`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_inclusive
[`slice::split_inclusive_mut`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_inclusive_mut
[`str::split_inclusive`]: https://doc.rust-lang.org/stable/std/primitive.str.html#method.split_inclusive
[`task::Wake`]: https://doc.rust-lang.org/stable/std/task/trait.Wake.html
[`Seek::stream_position`]: https://doc.rust-lang.org/stable/std/io/trait.Seek.html#method.stream_position
[`Peekable::next_if`]: https://doc.rust-lang.org/stable/std/iter/struct.Peekable.html#method.next_if
[`Peekable::next_if_eq`]: https://doc.rust-lang.org/stable/std/iter/struct.Peekable.html#method.next_if_eq